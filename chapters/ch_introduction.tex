\chapter{Introduction}

In a classical computer, a bit may be represented by two levels of electric charge stored in a capacitor or the presence or absence in a conducting path of a circuit. A quantum computer must instead be composed of elementary parts that are fundamentally different due to the laws of quantum mechanics, so-called \emph{qubits}, controlled by quantum logic gates. Many physical systems are currently under consideration to be used as qubits. The most promising candidates include defects in diamonds, trapped ions, photons, and superconducting qubits. At the same time, there exists a whole other field that focuses on the development of quantum algorithms that would run on the quantum computer. The development of physical qubits is arguably the current bottleneck for quantum computing as a whole. There exists already many quantum algorithms, but there are no qubits yet that are ``good enough''.

To run these quantum algorithms, given that we have some reasonably well-behaved qubits, we still need to scale up from single qubits to large-scale machines capable of these algorithms. The quantum computer \emph{architecture} determines how the qubits should be connected to each other and how high-level operations can be performed and communicated to the individual qubits. One such architecture that is commonly used is Kitaev's surface codes. It is defined by a set of stabilizers which act on a set of physical qubits that lie on the edges of a square lattice \cite{dennis2002topological, kitaev2003fault}, where many physical qubits \emph{encode} a logical state. Recent advances in quantum computing have resulted in two 53-qubit processors both applying this architecture, one from IBM and the other by Google. While the claims of the latter reaching quantum supremacy have been wildly disputed \cite{arute2019quantum}, these advances demonstrate the fortuity of surface codes as the leading architecture for quantum computing nonetheless.   

Another integral part of the quantum architecture is the implementation of quantum error correction and fault-tolerant quantum logic gates. Even or a completely isolated system, environmental noise can alter and destroy the volatile quantum states in our quantum computer. As we interact with the system to do computations, more noise is introduced to the system. As these effects are unavoidable, one must instead try to find and correct all the errors that have accumulated due to environmental noise and our interactions. In this regard, the surface code also has promise as it has the benefit of locality and high error threshold, which translates to only local interactions and high robustness against errors. 

The task of finding errors and correcting them such that the delicate quantum states are preserved is left to the decoder. Many types of decoders for the surface code exist today. While many of the decoders of the recent years have focussed on increasing the resilience against errors, the scalability of the decoder have been neglected and no decoder to day is fast enough to correct for the accumulation of errors on a physical qubit \cite{anwar2014fast, duclos2010fast, herold2015cellular, hutter2014efficient, watson2015fast, wootton2012high, bravyi2014efficient, heim2016optimal}.

In this thesis, we compare the performance of two decoders for the surface code; the Minimum-Weight Perfect Matching decoder and the Union-Find decoder \cite{delfosse2017almost}, and introduce a new type of decoder; the Union-Find Balanced-Bloom decoder, that manages to combine advantages both. Chapters \ref{ch:qec} and \ref{ch:surfacecode} introduces the concepts of quantum error correction and surface codes in general. We describe the Minimum-Weight Perfect Matching decoder and the Union-Find decoder and inspect their performances by numerical analyses in Chapters \ref{ch:mwpm} and \ref{ch:UFdecoder}. We describe a series of implementations and modifications from Section \ref{sec:bucketwg} onward to Chapter \ref{ch:ufbb} on the Union-Find Balanced-Bloom decoder. 