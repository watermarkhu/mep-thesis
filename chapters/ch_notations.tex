\chapter*{Notations}
\addcontentsline{toc}{chapter}{Notations}
In this chapter, we introduce the notations that we will be using throughout this thesis. With the defined notations, we also list the symbols used in this thesis. 

\paragraph{Quantum operator}
\begin{itemize}[leftmargin=4em, align=left]
    \item[$\hat{X}$]  Hatted symbols denote quantum operators on a quantum state.
\end{itemize}

\paragraph{Sets, lists, and groups}
\begin{itemize}[leftmargin=4em, align=left]
    \item[$\m{X}$]  Calligraphic symbols denote some set  or list of elements of the some type, or groups. 
\end{itemize}

\paragraph{Functions on sets}
\begin{itemize}[leftmargin=4em, align=left]
    \item[$\n{X}$]  Scripted symbols denote some function on a set, that has a set with elements of a different type as output. Set functions exists only to simplify notations. 
\end{itemize}

\paragraph{Algorithms}
\begin{itemize}[leftmargin=4em, align=left]
    \item[\codefunc{AlgorithmX}] Capitalized mono-spaced refer to some applied function or algorithm. 
\end{itemize}

\paragraph{Object-attribute notation}
\begin{itemize}[leftmargin=4em, align=left]
    \item[$x.var$]  Symbols with $.$ in between denote some attribute $var$ stored at the object $x$.
\end{itemize}
\emph{In this thesis, we will use simulated results to benchmark and compare the performance for several types of decoders for the surface code (see Chapters \ref{ch:surfacecode}, \ref{ch:UFdecoder}). These simulations are performed using our own simulation package (see Appendix \ref{ap:oopsurfacecode}), which utilizes an object-oriented programming structure. In this structure, instances of an object, which is equivalent to elements of some set, have attributes that are stored at the object instance.}

\paragraph{Others}
\begin{itemize}[leftmargin=4em, align=left]
    \item[$(u,v)$]  Edges of a graph can be denoted with the vertices $u,v$ that supports it.
    \item[$\tilde{X}$]  Refers to some instance of $X$, e.g. $\tilde{\m{X}}$ denotes some set $\m{X}$. 
    \item[$\m{O}$] Big O notation for describing a the limiting behavior of a function when the argument increases in size. 
\end{itemize}




% In this chapter, we will present an object-oriented implementation of surface code simulations. The goal of this chapter is not to describe in detail the classes and methods used for these simulations, but mainly introduce the notion of object attributes. In the remainder of the thesis, we will often refer to variables that are stored \emph{at} some physical entity, with which we mean that the variable is stored as an attribute at the class instance of that entity. 


