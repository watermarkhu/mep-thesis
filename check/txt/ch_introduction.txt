Introduction

In a classical computer, a bit may be represented by two levels of electric charge stored in a capacitor or the presence or absence in a conducting path of a circuit. A quantum computer must instead be composed of elementary parts that are fundamentally different due to the laws of quantum mechanics, so-called qubits, controlled by quantum logic gates. There are many physical systems that are currently under consideration to be used as qubits. The most promising candidates include defects in diamonds, trapped ions, photons, and superconducting qubits. At the same time, there exists a whole other field that focuses on the development of quantum algorithms that would run on the quantum computer. The development of physical qubits is actually but arguably the current bottleneck for quantum computing as a whole, where many algorithms already exist. Still, there are no qubits that are ``good enough''.

To runs these quantum algorithms, given that we have some reasonably well-behaving qubits, we still need to scale up from single qubits to large-scale machines that are capable of these said algorithms. The quantum computer architecture determines how the qubits should be connected to each other and how high-level operators can be performed and communicated to the individual qubits. One such architecture that is commonly used is Kitaev's surface codes. It is defined by a set of stabilizers which act on a set of physical qubits that lie on the edges of a square lattice [0], where many physical qubits encode a logical state. Recent advances in quantum computing have resulted in two 53-qubit processors applying applies this architecture, one from IBM and the other by Google. While the claims of the latter reaching quantum supremacy have been wildly disputed [0], these advances demonstrate the fortuity of surface codes as the leading architecture for quantum computing nonetheless.   

Another integral part of the quantum architecture is the implementation of quantum error correction and fault-tolerant quantum logic gates. Even or a completely isolated system, environmental noise can alter and destroy the volatile quantum states in our quantum computer. As we interact with the system to do computations, more noise is introduced to the system. As these effects are unavoidable, one must instead try to find and correct all the errors that have accumulated due to environmental noise and our interactions. In this regard, the surface code also has promise as it has the benefit of locality and high error threshold, which translates to only local interactions and high robustness against errors. 

The task of finding errors and correcting them such that the delicate quantum states are preserved is left to the decoder. In this thesis, we compare the performance of two decoders for the surface code; the Minimum-Weight Perfect Matching decoder and the Union-Find decoder, and introduce a new type of decoder, the Union-Find Balanced-Bloom decoder, that manages to combine advantages both. Chapters X and X introduces the concepts of quantum error correction and surface codes in general. We describe the Minimum-Weight Perfect Matching decoder and the Union-Find decoder and inspect their performances by numerical analyses in Chapters X and X. We describe a series of implementations and modifications from Section X onward to Chapter X, resulting in the Union-Find Balanced-Bloom decoder. 
